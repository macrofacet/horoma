<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Horoma - Color Explorer</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
		
		<script async src="https://unpkg.com/es-module-shims@1.5.8/dist/es-module-shims.js"></script>
		<script type="importmap">
			{
			  "imports": {
				"three": "https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.module.js",
				"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/",
				"dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"
			  }
			}
		  </script>
	</head>
	<body>
		<div id="xyYView" style="display:inline-block"></div>
	
		<script type='x-shader/x-vertex' id='point_vs'>

			#define float3 vec3
			#define float2 vec2
			#define float3x3 mat3
			#define mul(a, b) b * a

			#define saturate(a) clamp(a, 0.0f, 1.0f)

			float3x3 inv_f33(float3x3 m) {
				float d = m[0].x * (m[1].y * m[2].z - m[2].y * m[1].z) -
						  m[0].y * (m[1].x * m[2].z - m[1].z * m[2].x) +
						  m[0].z * (m[1].x * m[2].y - m[1].y * m[2].x);
				float id = 1.0f / d;
				float3x3 c = float3x3(1,0,0,0,1,0,0,0,1);
				c[0].x = id * (m[1].y * m[2].z - m[2].y * m[1].z);
				c[0].y = id * (m[0].z * m[2].y - m[0].y * m[2].z);
				c[0].z = id * (m[0].y * m[1].z - m[0].z * m[1].y);
				c[1].x = id * (m[1].z * m[2].x - m[1].x * m[2].z);
				c[1].y = id * (m[0].x * m[2].z - m[0].z * m[2].x);
				c[1].z = id * (m[1].x * m[0].z - m[0].x * m[1].z);
				c[2].x = id * (m[1].x * m[2].y - m[2].x * m[1].y);
				c[2].y = id * (m[2].x * m[0].y - m[0].x * m[2].y);
				c[2].z = id * (m[0].x * m[1].y - m[1].x * m[0].y);
				return c;
			  }

			float3 xyY_to_XYZ(float3 xyY)
			{
				if(xyY.y == 0.0f)
					return float3(0, 0, 0);

				float Y = xyY.z;
				float X = (xyY.x * Y) / xyY.y;
				float Z = ((1.0f - xyY.x - xyY.y) * Y) / xyY.y;

				return float3(X, Y, Z);
			}

			float3 unproject(float2 xy)
			{
				return xyY_to_XYZ(float3(xy.x, xy.y, 1));				
			}

			float3x3 primaries_to_matrix(float2 xy_red, float2 xy_green, float2 xy_blue, float2 xy_white)
			{
				float3 XYZ_red = unproject(xy_red);
				float3 XYZ_green = unproject(xy_green);
				float3 XYZ_blue = unproject(xy_blue);
				
				float3 XYZ_white = unproject(xy_white);
				
				float3x3 temp = float3x3(
							XYZ_red.x,	XYZ_green.x,	XYZ_blue.x,
							1.0f,	1.0f,	1.0f,
							XYZ_red.z,	XYZ_green.z,	XYZ_blue.z);

				float3x3 inverse = inv_f33(temp);
				float3 scale = mul(inverse, XYZ_white);
				
				return float3x3(
					scale.x * XYZ_red.x, scale.y * XYZ_green.x,	scale.z * XYZ_blue.x,
					scale.x * XYZ_red.y, scale.y * XYZ_green.y,	scale.z * XYZ_blue.y,
					scale.x * XYZ_red.z, scale.y * XYZ_green.z,	scale.z * XYZ_blue.z);
			}

			float3x3 ComputeCompressionMatrix(float2 xyR, float2 xyG, float2 xyB, float2 xyW, float compression)
			{
				float scale_factor = 1.0f / (1.0f - compression);
				float2 R = ((xyR - xyW) * scale_factor) + xyW;
				float2 G = ((xyG - xyW) * scale_factor) + xyW;
				float2 B = ((xyB - xyW) * scale_factor) + xyW;
				float2 W = xyW;

				return primaries_to_matrix(R, G, B, W);
			}


			float3 open_domain_to_normalized_log2(float3 in_od, float minimum_ev, float maximum_ev)
			{
				const float middle_grey = 0.18f;
				float total_exposure = maximum_ev - minimum_ev;

				float3 output_log = clamp(log2(in_od / middle_grey), minimum_ev, maximum_ev);
				
				return (output_log - minimum_ev) / total_exposure;
			}


			float equation_scale(float x_pivot, float y_pivot, float slope_pivot, float power)
			{
				return pow(pow((slope_pivot * x_pivot), -power) * (pow((slope_pivot * (x_pivot / y_pivot)), power) - 1.0), -1.0 / power);
			}

			float equation_hyperbolic(float x, float power)
			{
				return x / pow(1.0 + pow(x, power), 1.0f / power);
			}

			float equation_term(float x, float x_pivot, float slope_pivot, float scale)
			{
				return (slope_pivot * (x - x_pivot)) / scale;
			}

			float equation_curve(float x, float x_pivot, float y_pivot, float slope_pivot, float toe_power, float shoulder_power, float scale)
			{
				if(scale < 0.0f)
				{
					return scale * equation_hyperbolic(equation_term(x, x_pivot, slope_pivot, scale), toe_power) + y_pivot;
				}
				else
				{
					return scale * equation_hyperbolic(equation_term(x,x_pivot,slope_pivot,scale), shoulder_power) + y_pivot;
				}
			}

			float equation_full_curve(float x, float x_pivot, float y_pivot, float slope_pivot, float toe_power, float shoulder_power)
			{
				float scale_x_pivot = x >= x_pivot ? 1.0f - x_pivot : x_pivot;
				float scale_y_pivot = x >= x_pivot ? 1.0f - y_pivot : y_pivot;

				float toe_scale = equation_scale(scale_x_pivot, scale_y_pivot, slope_pivot, toe_power);
				float shoulder_scale = equation_scale(scale_x_pivot, scale_y_pivot, slope_pivot, shoulder_power);				

				float scale = x >= x_pivot ? shoulder_scale : -toe_scale;

				return equation_curve(x, x_pivot, y_pivot, slope_pivot, toe_power, shoulder_power, scale);
			}


			/// ACTUAL SHADER
			
			uniform mat3 convMatXYZ;	
			uniform vec2 whitePoint;

			uniform float exposure;

			uniform float compression;
			uniform float min_ev;
			uniform float max_ev;
			uniform float slope;
			uniform float toe_power;
			uniform float shoulder_power;
			
			uniform float saturation;
			uniform float rawlerp;

			varying vec3 vColorRGB;	


			void main() {
				vec3 vColor = max(color, 0.0f);

				vColor *= pow(2.0f, exposure);
				// AgX
				float3x3 sRGB_to_XYZ = primaries_to_matrix(float2(0.64,0.33),
													float2(0.3,0.6), 
													float2(0.15,0.06), 
													float2(0.3127, 0.3290));

				float3x3 adjusted_to_XYZ = ComputeCompressionMatrix(float2(0.64,0.33),
																	float2(0.3,0.6), 
																	float2(0.15,0.06), 
																	float2(0.3127, 0.3290), compression);

				float3 rgb = vColor;								

				float3x3 XYZ_to_adjusted = inv_f33(adjusted_to_XYZ);
				float3x3 XYZ_to_sRGB = inv_f33(sRGB_to_XYZ);
				
				float3 xyz = mul(sRGB_to_XYZ, rgb);
				float3 ajustedRGB = mul(XYZ_to_adjusted, xyz);

				//const float slope = 2.3f;
				//const float toe_power = 1.9f;
				//const float shoulder_power = 3.1f;
				//const float min_ev = -10.0f;
				//const float max_ev = 6.5f;

				float x_pivot = abs(min_ev) / (max_ev - min_ev);
				float y_pivot = 0.5f;

				float3 log = open_domain_to_normalized_log2(ajustedRGB, min_ev, max_ev);

				float outputR = equation_full_curve(log.r, x_pivot, y_pivot, slope, toe_power, shoulder_power);
				float outputG = equation_full_curve(log.g, x_pivot, y_pivot, slope, toe_power, shoulder_power);
				float outputB = equation_full_curve(log.b, x_pivot, y_pivot, slope, toe_power, shoulder_power);

				vColor = saturate(float3(outputR, outputG, outputB));


				// Saturation
				vec3 wgt = vec3(0.2126729f,  0.7151522f,  0.0721750f); // srgb luminance
				vec3 des = vec3(dot(vColor, wgt));
				vec3 sColor = mix(des, vColor, saturation);
		
				sColor = clamp(sColor, 0.f, 1.f);

				// Lerp between raw and image
				vec3 fp = mix(color, sColor, rawlerp);	

				vColor = fp;

			/*
			 	vec3 xyz = convMatXYZ * vColor;
				
				float sum = xyz.x + xyz.y + xyz.z;
				vec3 xyY = vec3(0, 0, 0);
				if(sum != 0.0)
				{
					xyY.x = xyz.x / sum;
					xyY.y = xyz.y / sum;
					xyY.z = xyz.y;
				}
				else
				{
					xyY.x = whitePoint.x;
					xyY.y = whitePoint.y;
					xyY.z = xyz.y;
				}
			*/

			  vec4 mvPosition = modelViewMatrix * vec4( vColor, 1.0 );
			  gl_PointSize = 5.0;
			  gl_Position = projectionMatrix * mvPosition;

			  vColorRGB = vColor;
			}
		
		  </script>
		
		  <script type='x-shader/x-fragment' id='point_fs'>
			varying vec3 vColorRGB;	
		
			void main() {
				if (dot(gl_PointCoord-0.5,gl_PointCoord-0.5)>0.25)
					discard;
				else
			  		gl_FragColor = vec4( vColorRGB, 1 );
			}
		  </script>


		<script type="x-shader/x-vertex" id="vertexShader">
			uniform mat3 convMatXYZ;
			uniform vec2 whitePoint;
			varying vec3 vColorRGB;
			void main() {

				vec3 pos = position;
				vec3 rgb = (pos + 0.5); // box is centered at 0,0,0
 
				vec3 xyz = convMatXYZ * rgb;
				vec3 position;
				float sum = xyz.x + xyz.y + xyz.z;
				vec3 xyY = vec3(0, 0, 0);
				if(sum != 0.0)
				{
					xyY.x = xyz.x / sum;
					xyY.y = xyz.y / sum;
					xyY.z = xyz.y;
				}
				else
				{
					xyY.x = whitePoint.x;
					xyY.y = whitePoint.y;
					xyY.z = xyz.y;
				}
				position = xyY;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;

				vColorRGB = rgb;
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">
			varying vec3 vColorRGB;
			uniform float opacity;
			void main() {
				vec3 rgb = vColorRGB;
				if(any(greaterThan(rgb - vec3(1.0, 1.0, 1.0), vec3(0.001, 0.001, 0.001))) || any(lessThan(rgb, -vec3(0.001, 0.001, 0.001))))
				{	
					gl_FragColor = vec4( 0.1, 0.1, 0.1, opacity );	
				}
				else
				{				
					gl_FragColor = vec4( rgb, opacity );					
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";
			import { OrbitControls } from "three/addons/controls/OrbitControls";
			import { EXRLoader } from "three/addons/jsm/loaders/EXRLoader";

			import dat from "dat.gui";


			import * as Utils from './js/utils.js'
			import * as Generator from './js/generator.js'
			import * as Inset from './js/inset.js'
			
			import * as Lut from './js/lut.js'

			var images = {};

			new EXRLoader().setDataType(THREE.FloatType)
			.load( "./images/red_xmas_rec709.exr", function ( texture, textureData ) {
							images.xmas = textureData.data;
						});
			new EXRLoader().setDataType(THREE.FloatType)
			.load( "./images/mery_lightSaber_lin_srgb.exr", function ( texture, textureData ) {
							images.lightsaber = textureData.data;
						});

			new EXRLoader().setDataType(THREE.FloatType)
			.load( "./images/blue_bar_709.exr", function ( texture, textureData ) {
							images.bar = textureData.data;
						});
						

			const lutMap = {
				'Bourbon 64.CUBE': null,
				'Chemical 168.CUBE': null,
			};

			Object.keys( lutMap ).forEach( name => {
				const loader = new THREE.FileLoader();
				loader.setResponseType('text');
				loader.load('luts/' + name, text => {
					lutMap[ name ] =  new Lut.LUTCubeParser().parse(text);
				});
			});

			var aspect = window.innerWidth / window.innerHeight;

			var xyYscene = new THREE.Scene();
			xyYscene.background = new THREE.Color( "rgb(127,127,127)" );
			var frustumSize = 2;
			
			var perspCamera_xyY = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000 );
			perspCamera_xyY.position.z = 5;
			
			var xyYrenderer = new THREE.WebGLRenderer();
			xyYrenderer.setSize( window.innerWidth, window.innerHeight );
			document.getElementById("xyYView").appendChild( xyYrenderer.domElement );

			var boxGeo = new THREE.BoxGeometry(1, 1, 1, 20, 20, 20);

			var material709_xyY = new THREE.ShaderMaterial( {
			uniforms: {
				convMatXYZ: { value: Utils.sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
				opacity: {value: 0.1}
			},
			depthTest: false,
			vertexShader: document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );

			material709_xyY.transparent = true;
			material709_xyY.opacity = 0.1;

			var cube709_xyY = new THREE.Mesh( boxGeo, material709_xyY );
			cube709_xyY.renderOrder = 0;
			//xyYscene.add(cube709_xyY);

			var axesHelper = new THREE.AxesHelper( 1 );
			xyYscene.add( axesHelper );

			var size = 10;
			var divisions = 10;

			var controls_xyY = new OrbitControls( perspCamera_xyY, xyYrenderer.domElement );
			controls_xyY.damping = 0.2;
			
			var pointCloudGeo = new THREE.BufferGeometry();

			const positions = [];
			const colors = [];
			pointCloudGeo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
			pointCloudGeo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
			pointCloudGeo.computeBoundingSphere();

			// uniforms
			var uniforms = {
				convMatXYZ: { value: Utils.sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
				saturation: {value: 1.0},
				rawlerp:{value:1.0},
				exposure:{value:1.0},
				compression:{value:0.17},
				min_ev:{value:-10.0},
				max_ev:{value:6.5},
				slope:{value:2.3},
				toe_power:{value:1.9},
				shoulder_power:{value:3.1}
			};

			// point cloud material
			var pointShaderMaterial = new THREE.ShaderMaterial( {
				uniforms:     uniforms,
				vertexShader:   document.getElementById( 'point_vs' ).textContent,
				fragmentShader: document.getElementById( 'point_fs' ).textContent,
				transparent:  true,
				vertexColors: true
			});

			var point_xyY = new THREE.Points(pointCloudGeo, pointShaderMaterial);
			point_xyY.renderOrder = 1;
			xyYscene.add( point_xyY );
			

			// UI

			var params = { 
						generator:"generic",
						steps:1,
						start:-10,
						range:20,
						substeps:1,
						ratio:[0,0,0],
						image:"xmas",
						exposure:0,
						useLut:false,
						lut:"Bourbon 64.CUBE",
						compression:0,
						min_ev:-10,
						max_ev:7,
						slope:2.5,
						toe_power:1.9,
						shoulder_power:3.1,
						saturation:1,
						lerp:1,
						ortho:false};

			var gui = new dat.GUI();

			var samples = [];
			function updateSamples()
			{
				samples.length = 0;

				const steps = params.steps;
				const range = params.range;
				const start = params.start;
				const substeps = params.substeps;
				
				switch(params.generator)
				{
					case 'single':
					var ratio = new THREE.Vector3();
					ratio.x = params.ratio[0];
					ratio.y = params.ratio[1];
					ratio.z = params.ratio[2];

					samples = Generator.GenerateLine(ratio, substeps, start, range);
					break;
					
					case 'image' :
						var sourceData = null;
						switch(params.image)
						{
							case "lightsaber": sourceData = images.lightsaber; break;
							case "bar": sourceData = images.bar; break;
							case "xmas": default: sourceData = images.xmas; break;
						}
					for(var i = 0; i < sourceData.length; i+=4)
					{
						samples.push(new THREE.Vector3(sourceData[i], sourceData[i+1], sourceData[i+2]));
					}
					break;

					case 'generic':
					default:
						samples = Generator.GenerateRamp(steps, substeps, start, range);
					break;

				}

				updatePoint();
			}

			function updateUniforms()
			{
				pointShaderMaterial.uniforms.exposure.value = params.exposure;
				
				pointShaderMaterial.uniforms.compression.value = params.compression;
				pointShaderMaterial.uniforms.min_ev.value = params.min_ev;
				pointShaderMaterial.uniforms.max_ev.value = params.max_ev;
				pointShaderMaterial.uniforms.slope.value = params.slope;
				pointShaderMaterial.uniforms.toe_power.value = params.toe_power;
				pointShaderMaterial.uniforms.shoulder_power.value = params.shoulder_power;

				pointShaderMaterial.uniforms.rawlerp.value = params.lerp;
				pointShaderMaterial.uniforms.saturation.value = params.saturation;
			}
			
			function updatePoint()
			{	
				Inset.setCompressionMatrix(params.compression);
				
				const positions = [];
				const colors = [];
				
				for ( let s = 0; s < samples.length; s ++ )
				{
					var p = samples[s];
					p.x = p.x * Math.pow(2, params.exposure);
					p.y = p.y * Math.pow(2, params.exposure);
					p.z = p.z * Math.pow(2, params.exposure);	
					
					colors.push(p.x, p.y, p.z);

					p.max(new THREE.Vector3(0, 0, 0));

					var tp = new THREE.Vector3();
					if(params.useLut)
					{
						var lut = lutMap[params.lut];
						var lx = Utils.open_domain_to_normalized_log2(p.x, -10, 6.5);
						var ly = Utils.open_domain_to_normalized_log2(p.y, -10, 6.5);
						var lz = Utils.open_domain_to_normalized_log2(p.z, -10, 6.5);
						var lp = new THREE.Vector3(lx, ly, lz);
						lp.clampScalar(0, 1);
						tp = lut.trilinear_lookup(lp);
					}
					else
					{
						tp = Inset.applyTransform(p.clone(), params.slope, params.toe_power, params.shoulder_power, params.min_ev, params.max_ev);
					}

					positions.push(tp.x, tp.y, tp.z);
				}

				pointCloudGeo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				pointCloudGeo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				pointCloudGeo.computeBoundingSphere();

				for (var i in gui.__controllers) {
					gui.__controllers[i].updateDisplay();
				}
			}

			updateSamples();
			updateUniforms();

			var generatorFolder = gui.addFolder("generator");

			generatorFolder.add(params, 'generator', ['generic', 'single', 'image']).onChange(updateSamples);

			generatorFolder.add(params, 'steps', 1, 20, 1).onChange(updateSamples);
			generatorFolder.add(params, 'start', -20, 20, 1).onChange(updateSamples);
			generatorFolder.add(params, 'range', 0, 20, 1).onChange(updateSamples);
			generatorFolder.add(params, 'substeps', 1, 20, 1).onChange(updateSamples);

			generatorFolder.addColor(params, 'ratio').onChange(updateSamples);

			generatorFolder.add(params, 'image', ['xmas', 'lightsaber', 'bar']).onChange(updateSamples);
			
			var algorithmFolder = gui.addFolder("algorithm");
			algorithmFolder.add(params, 'exposure', -20, 20, 0.1).onChange(updateUniforms);

			algorithmFolder.add(params, 'compression', 0, 0.5, 0.0001).onChange(updateUniforms);
			algorithmFolder.add(params, 'min_ev', -20, 20, 1).onChange(updateUniforms);
			algorithmFolder.add(params, 'max_ev', 0, 20, 1).onChange(updateUniforms);

			algorithmFolder.add(params, 'slope', 0, 10, 0.01).onChange(updateUniforms);
			algorithmFolder.add(params, 'toe_power', 0, 10, 0.01).onChange(updateUniforms);
			algorithmFolder.add(params, 'shoulder_power', 0, 10, 0.01).onChange(updateUniforms);

			algorithmFolder.add(params, 'useLut').onChange(updatePoint);
			algorithmFolder.add(params, 'lut', Object.keys( lutMap )).onChange(updatePoint);

			gui.add(params, 'saturation', 0, 4, 0.001).onChange(updateUniforms);
			gui.add(params, 'lerp', 0, 1, 0.01).onChange(updateUniforms);

			
			
			function render() {
				
				requestAnimationFrame( render );
				xyYrenderer.render( xyYscene, perspCamera_xyY );

			}

			render();

			window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){

				var aspect = (window.innerWidth) / window.innerHeight;

				perspCamera_xyY.aspect = aspect;
			    perspCamera_xyY.updateProjectionMatrix();
			    xyYrenderer.setSize( window.innerWidth, window.innerHeight );
			}
		</script>
	</body>
</html>

