<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Horoma - Color Explorer</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="XYZView" style="display:inline-block"></div>
		<div id="xyYView" style="display:inline-block"></div>

		<script src="js/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>


		<script type="text/javascript" src="js/dat.gui.min.js"></script>

		<script type='x-shader/x-vertex' id='point_vs'>
			
			uniform mat3 convMatXYZ;	
			uniform vec2 whitePoint;
			varying vec3 vColorXYZ;	
			void main() {
			
			 	vec3 xyz = convMatXYZ * position;
				 vColorXYZ = xyz;
				
				float sum = xyz.x + xyz.y + xyz.z;
				vec3 xyY = vec3(0, 0, 0);
				if(sum != 0.0)
				{
					xyY.x = xyz.x / sum;
					xyY.y = xyz.y / sum;
					xyY.z = xyz.y;
				}
				else
				{
					xyY.x = whitePoint.x;
					xyY.y = whitePoint.y;
					xyY.z = xyz.y;
				}

			  vec4 mvPosition = modelViewMatrix * vec4( xyY, 1.0 );
			  gl_PointSize = 5.0;
			  gl_Position = projectionMatrix * mvPosition;
			}
		
		  </script>
		
		  <script type='x-shader/x-fragment' id='point_fs'>
			
			varying vec3 vColorXYZ;
			uniform mat3 XYZ_to_sRGB;
		
			void main() {
				vec3 rgb = XYZ_to_sRGB * vColorXYZ;
			  gl_FragColor = vec4( rgb, 1 );
			}
		  </script>


		<script type="x-shader/x-vertex" id="vertexShader">

			mat3 transpose(mat3 m)
			{
			  return mat3(m[0][0], m[1][0], m[2][0],
			              m[0][1], m[1][1], m[2][1],
			              m[0][2], m[1][2], m[2][2]);
			}

			uniform mat3 convMatXYZ;
			uniform vec2 whitePoint;
			uniform bool useXYZ;
			varying vec3 vColorXYZ;
			varying vec3 vColorRGB;
			void main() {

				vec3 pos = position;
				vec3 rgb = (pos + 0.5); // box is centered at 0,0,0
 
				vec3 xyz = convMatXYZ * rgb;
				vec3 position;
				if(useXYZ)
				{
					position = xyz;
				}
				else
				{
					float sum = xyz.x + xyz.y + xyz.z;
					vec3 xyY = vec3(0, 0, 0);
					if(sum != 0.0)
					{
						xyY.x = xyz.x / sum;
						xyY.y = xyz.y / sum;
						xyY.z = xyz.y;
					}
					else
					{
						xyY.x = whitePoint.x;
						xyY.y = whitePoint.y;
						xyY.z = xyz.y;
					}
					position = xyY;
				}

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;

				vColorXYZ = xyz;
				vColorRGB = rgb;
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">
			mat3 transpose(mat3 m)
			{
			  return mat3(m[0][0], m[1][0], m[2][0],
			              m[0][1], m[1][1], m[2][1],
			              m[0][2], m[1][2], m[2][2]);
			}

			uniform mat3 XYZ_to_sRGB;
			varying vec3 vColorXYZ;
			varying vec3 vColorRGB;
			uniform float opacity;
			void main() {
				vec3 rgb = XYZ_to_sRGB * vColorXYZ;
				if(any(greaterThan(rgb - vec3(1.0, 1.0, 1.0), vec3(0.001, 0.001, 0.001))) || any(lessThan(rgb, -vec3(0.001, 0.001, 0.001))))
				{	
					gl_FragColor = vec4( 0.1, 0.1, 0.1, opacity );	
				}
				else
				{				
					gl_FragColor = vec4( rgb, opacity );					
				}
			}
		</script>
		<script>

			function XYZ_to_xyY(XYZColor, whitePoint)
			{
				var XYZ = XYZColor;
				var sum = XYZ.x + XYZ.y + XYZ.z;
				var xyY = new THREE.Vector3(0, 0, 0);
				if(sum != 0.0)
				{
					xyY.x = XYZ.x / sum;
					xyY.y = XYZ.y / sum;
					xyY.z = XYZ.y;
				}
				else
				{
					xyY.x = whitePoint.x;
					xyY.y = whitePoint.y;
					xyY.z = XYZ.y;
				}
				return xyY;
			}

			function xyY_to_XYZ(xyY)
			{
				if(xyY.y == 0)
					return new THREE.Vector3(0, 0, 0);

				var Y = xyY.z;
				var X = (xyY.x * Y) / xyY.y;
				var Z = ((1 - xyY.x - xyY.y) * Y) / xyY.y;

				return new THREE.Vector3(X, Y, Z);
			}

			function unproject(xy)
			{
				return xyY_to_XYZ(new THREE.Vector3(xy.x, xy.y, 1));				
			}

			// https://mina86.com/2019/srgb-xyz-matrix/
			function primaries_to_scale_vector(xy_red, xy_green, xy_blue, xy_white)
			{
				var XYZ_red = unproject(xy_red);
				var XYZ_green = unproject(xy_green);
				var XYZ_blue = unproject(xy_blue);
				
				var XYZ_white = unproject(xy_white);
				
				var temp = new THREE.Matrix3();
				temp.set( 	XYZ_red.x,	XYZ_green.x,	XYZ_blue.x,
							1,	1,	1,
							XYZ_red.z,	XYZ_green.z,	XYZ_blue.z,);
				var inverse = new THREE.Matrix3().getInverse(temp);
				return XYZ_white.applyMatrix3(inverse);
			}

			function primaries_to_matrix(xy_red, xy_green, xy_blue, xy_white)
			{
				var XYZ_red = unproject(xy_red);
				var XYZ_green = unproject(xy_green);
				var XYZ_blue = unproject(xy_blue);
				
				var XYZ_white = unproject(xy_white);
				
				var temp = new THREE.Matrix3();
				temp.set( 	XYZ_red.x,	XYZ_green.x,	XYZ_blue.x,
							1,	1,	1,
							XYZ_red.z,	XYZ_green.z,	XYZ_blue.z,);
				var inverse = new THREE.Matrix3().getInverse(temp);
				var scale = XYZ_white.applyMatrix3(inverse);
				
				var out = new THREE.Matrix3();
				out.set( 	scale.x * XYZ_red.x, scale.y * XYZ_green.x,	scale.z * XYZ_blue.x,
							scale.x * XYZ_red.y, scale.y * XYZ_green.y,	scale.z * XYZ_blue.y,
							scale.x * XYZ_red.z, scale.y * XYZ_green.z,	scale.z * XYZ_blue.z,)
				return out;
			}

			function ComputeCompressionMatrix(xyR, xyG, xyB, xyW, compression)
			{
				var scale_factor = 1 / (1 - compression);
				xyR.sub(xyW).multiplyScalar(scale_factor).add(xyW);
				xyG.sub(xyW).multiplyScalar(scale_factor).add(xyW);
				xyB.sub(xyW).multiplyScalar(scale_factor).add(xyW);
				
				return primaries_to_matrix(xyR, xyG, xyB, xyW);
			}

			var sRGB_to_XYZ = primaries_to_matrix(new THREE.Vector2(0.64,0.33),
														new THREE.Vector2(0.3,0.6), 
														new THREE.Vector2(0.15,0.06), 
														new THREE.Vector2(0.3127, 0.3290));

			var adjusted_to_XYZ = ComputeCompressionMatrix(new THREE.Vector2(0.64,0.33),
														new THREE.Vector2(0.3,0.6), 
														new THREE.Vector2(0.15,0.06), 
														new THREE.Vector2(0.3127, 0.3290), 0.10);

			var XYZ_to_adjusted = new THREE.Matrix3().getInverse(adjusted_to_XYZ);

			var XYZ_to_sRGB = new THREE.Matrix3().getInverse(sRGB_to_XYZ);

			function applyTonemap(rgb)
			{
				var xyz = rgb.applyMatrix3(sRGB_to_XYZ);
				var ajustedRGB = xyz.applyMatrix3(XYZ_to_adjusted);

				ajustedRGB.x = (ajustedRGB.x) / (1 + ajustedRGB.x);
				ajustedRGB.y = (ajustedRGB.y) / (1 + ajustedRGB.y);
				ajustedRGB.z = (ajustedRGB.z) / (1 + ajustedRGB.z);

				//ajustedRGB.x = Math.min(Math.max(ajustedRGB.x, 0), 1);
				//ajustedRGB.y = Math.min(Math.max(ajustedRGB.y, 0), 1);
				//ajustedRGB.z = Math.min(Math.max(ajustedRGB.z, 0), 1);
				return ajustedRGB;
			}
			
			var aspect = (window.innerWidth * 0.4) / window.innerHeight;

			var XYZscene = new THREE.Scene();
			var perspCameraXYZ = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000 );
			perspCameraXYZ.position.z = 5;
			

			var xyYscene = new THREE.Scene();
			xyYscene.background = new THREE.Color( "rgb(127,127,127)" );
			var frustumSize = 2;
			/*
			var orthoCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
			orthoCamera.position.z = 5;
			*/
			
			var perspCamera_xyY = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000 );
			perspCamera_xyY.position.z = 5;

			var XYZrenderer = new THREE.WebGLRenderer();
			XYZrenderer.setSize( window.innerWidth * 0.4, window.innerHeight );
			document.getElementById("XYZView").appendChild( XYZrenderer.domElement );

			
			var xyYrenderer = new THREE.WebGLRenderer();
			xyYrenderer.setSize( window.innerWidth * 0.4, window.innerHeight );
			document.getElementById("xyYView").appendChild( xyYrenderer.domElement );

			var boxGeo = new THREE.BoxGeometry(1, 1, 1, 20, 20, 20);
			

			var material709 = new THREE.ShaderMaterial( {
			uniforms: {
				convMatXYZ: { value: sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
				XYZ_to_sRGB: {value : XYZ_to_sRGB},
				useXYZ: {value: true},
				opacity: {value: 0.8}
			},
			vertexShader: document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );
			
			material709.transparent = true;
			material709.opacity = 1.0;

			var material709_xyY = new THREE.ShaderMaterial( {
			uniforms: {
				convMatXYZ: { value: sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
				XYZ_to_sRGB: {value : XYZ_to_sRGB},
				useXYZ: {value: false},
				opacity: {value: 0.01}
			},
			vertexShader: document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );

			material709_xyY.transparent = true;
			material709_xyY.opacity = 0.01;
			
			var cube709_XYZ = new THREE.Mesh( boxGeo, material709 );
			XYZscene.add( cube709_XYZ );

			var cube709_xyY = new THREE.Mesh( boxGeo, material709_xyY );
			//xyYscene.add(cube709_xyY);

			var triangle = new THREE.Geometry();
			triangle.dynamic = true;
			triangle.vertices.push(new THREE.Vector3(-1, -1, 1));
			triangle.vertices.push(new THREE.Vector3(1, -1, 1));
			triangle.vertices.push(new THREE.Vector3(0, 1, 1));
			triangle.vertices.push(new THREE.Vector3(-1, -1, 1));

			var line = new THREE.Line(
				triangle,
			new THREE.LineBasicMaterial({ color: 0xFFFFFF })
			);
			XYZscene.add(line);

			var axesHelper = new THREE.AxesHelper( 1 );
			XYZscene.add( axesHelper );

			var axesHelper = new THREE.AxesHelper( 1 );
			xyYscene.add( axesHelper );


			var size = 10;
			var divisions = 10;

			var controlsXYZ = new THREE.OrbitControls( perspCameraXYZ, XYZrenderer.domElement );
			controlsXYZ.damping = 0.2;

			var controls_xyY = new THREE.OrbitControls( perspCamera_xyY, xyYrenderer.domElement );
			controls_xyY.damping = 0.2;
			
			var pointCloudGeo = new THREE.BufferGeometry();

			const positions = [];
			for ( let i = -10; i < 10; i ++ )
			{
				var ex = Math.pow(2, i);
				var p = new THREE.Vector3(1, 0, 0).multiplyScalar(ex);

				p = applyTonemap(p);

				positions.push( p.x, p.y, p.z );
			}

			pointCloudGeo.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );

			pointCloudGeo.computeBoundingSphere();

			//var pointsGeom = new THREE.Geometry();
			//var p = new THREE.Vector3();
			//pointsGeom.vertices.push( p );

			// uniforms
			var uniforms = {
				convMatXYZ: { value: sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
				XYZ_to_sRGB: {value : XYZ_to_sRGB},

				//color: { value: new THREE.Color( 0xffff00 ) },
			};

			// point cloud material
			var pointShaderMaterial = new THREE.ShaderMaterial( {
				uniforms:     uniforms,
				vertexShader:   document.getElementById( 'point_vs' ).textContent,
				fragmentShader: document.getElementById( 'point_fs' ).textContent,
				transparent:  true,
				//vertexColors: true

			});

			//var pointsMaterial = new THREE.PointsMaterial( { color: 0x888888, size:0.05 } );
			//var pointXYZ = new THREE.Points(pointCloudGeo, pointShaderMaterial);
			var point_xyY = new THREE.Points(pointCloudGeo, pointShaderMaterial);
			//XYZscene.add( pointXYZ );	
			xyYscene.add( point_xyY );


			

			var params = {xr:0.64, yr:0.33, xg:0.3, yg:0.6, xb:0.15, yb:0.06, xw:0.3127, yw:0.3290, 
						scale:1, compression:0, 
						r:0, g:0, b:0, 
						intensity:0,
						ar:0, ag:0, ab:0, 
						saturation:1,
						c:0,
						ortho:false};

			function lerp(a, b, t)
			{
				return (1 - t) * a + t * b;
			}

			var gui = new dat.GUI();

			function updatePoint()
			{
				
				/*
				var Ys = primaries_to_matrix(new THREE.Vector2(params.xr, params.yr), 
												new THREE.Vector2(params.xg, params.yg), 
												new THREE.Vector2(params.xb, params.yb), 
												new THREE.Vector2(params.xw, params.yw));

				triangle.vertices[0] = triangle.vertices[3] = new THREE.Vector3(params.xr, params.yr, (1 - params.scale) + Ys.x * params.scale);
				
				triangle.vertices[1] = new THREE.Vector3(params.xg, params.yg, (1 - params.scale) + Ys.y * params.scale);				
				triangle.vertices[2] = new THREE.Vector3(params.xb, params.yb, (1 - params.scale) + Ys.z * params.scale); 

				*/
				var xyR = new THREE.Vector2(params.xr, params.yr);
				var xyG = new THREE.Vector2(params.xg, params.yg);
				var xyB = new THREE.Vector2(params.xb, params.yb);
				var xyW = new THREE.Vector2(params.xw, params.yw);

				var scale_factor = 1 / (1 - params.compression);
				xyR.sub(xyW).multiplyScalar(scale_factor).add(xyW);
				xyG.sub(xyW).multiplyScalar(scale_factor).add(xyW);
				xyB.sub(xyW).multiplyScalar(scale_factor).add(xyW);
				
				var Y = primaries_to_scale_vector(xyR, xyG, xyB, xyW);

				var XYZR = xyY_to_XYZ(new THREE.Vector3(xyR.x, xyR.y, lerp(1, Y.x, params.scale)));
				var XYZG = xyY_to_XYZ(new THREE.Vector3(xyG.x, xyG.y, lerp(1, Y.y, params.scale)));
				var XYZB = xyY_to_XYZ(new THREE.Vector3(xyB.x, xyB.y, lerp(1, Y.z, params.scale)));
				var XYZW = xyY_to_XYZ(new THREE.Vector3(xyW.x, xyW.y, 1));

				var M = new THREE.Matrix3();
				M.set( 		XYZR.x, XYZG.x,	XYZB.x,
							XYZR.y, XYZG.y,	XYZB.y,
							XYZR.z, XYZG.z,	XYZB.z,)

				//material709.uniforms.convMatXYZ.value = M;
				//material709.uniforms.whitePoint.value = xyW;

				//material709_xyY.uniforms.convMatXYZ.value = M;
				//material709_xyY.uniforms.whitePoint.value = xyW;

				triangle.vertices[0] = triangle.vertices[3] = XYZR;
				
				triangle.vertices[1] = XYZG;			
				triangle.vertices[2] = XYZB;
				triangle.verticesNeedUpdate = true;

				/*var scaled
				var tonemappedRGB = applyTonemap(new THREE.Vector3(params.r, params.g, params.b).multiplyScalar(params.intensity), M);
				
				params.ar = tonemappedRGB.x;
				params.ag = tonemappedRGB.y;
				params.ab = tonemappedRGB.z;
				params.c = (Math.pow(params.ar, 1/2.2) * 255) << 16 | (Math.pow(params.ag, 1/2.2) * 255) << 8 | Math.pow(params.ab, 1/2.2) * 255;
				
				var XYZ_image = tonemappedRGB.applyMatrix3(sRGB_to_XYZ);
				pointXYZ.position.copy(XYZ_image);
				point_xyY.position.copy(XYZ_to_xyY(XYZ_image, xyW));
				*/
				adjusted_to_XYZ = ComputeCompressionMatrix(xyR, xyG, xyB, xyW, params.compression);
				XYZ_to_adjusted = new THREE.Matrix3().getInverse(adjusted_to_XYZ);

				var s = params.saturation;
				var si = 1 - s;
				var wgt = new THREE.Vector3(0.2126729,  0.7151522,  0.0721750);
				var SatMatrix = new THREE.Matrix3();
				SatMatrix.set( 	si * wgt.x + s, si * wgt.y,		si * wgt.z,
								si * wgt.x, 	si * wgt.y + + s,	si * wgt.z,
								si * wgt.x, 	si * wgt.y,		si * wgt.z + + s,)

				const positions = [];
				const steps = 20;
				for ( let r = 0; r <= steps; r ++ )
				{
					for ( let g = 0; g <= steps; g ++ )
					{
						for ( let b = 0; b <= steps; b ++ )
						{
							if(r == g && r == b) continue;
							for ( let i = -10; i <= 10; i ++ )
							{
								var ex = Math.pow(2, i);
								var p = new THREE.Vector3(r/steps, g/steps, b/steps).multiplyScalar(ex);

								var tp = applyTonemap(p);
								tp = tp.applyMatrix3(SatMatrix);
						
								tp.x = Math.min(Math.max(tp.x, 0), 1);
								tp.y = Math.min(Math.max(tp.y, 0), 1);
								tp.z = Math.min(Math.max(tp.z, 0), 1);

								positions.push( tp.x, tp.y, tp.z );
							}
						}
					}
				}

				pointCloudGeo.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );

				pointCloudGeo.computeBoundingSphere();



				for (var i in gui.__controllers) {
					gui.__controllers[i].updateDisplay();
				}
			}

			updatePoint();

			gui.add(params, 'xr', 0, 1, 0.0001).onChange(updatePoint);
			gui.add(params, 'yr', 0, 1, 0.0001).onChange(updatePoint);

			gui.add(params, 'xg', 0, 1, 0.0001).onChange(updatePoint);
			gui.add(params, 'yg', 0, 1, 0.0001).onChange(updatePoint);

			gui.add(params, 'xb', 0, 1, 0.0001).onChange(updatePoint);
			gui.add(params, 'yb', 0, 1, 0.0001).onChange(updatePoint);

			
			gui.add(params, 'xw', 0, 1, 0.0001).onChange(updatePoint);
			gui.add(params, 'yw', 0, 1, 0.0001).onChange(updatePoint);

			gui.add(params, 'scale', 0, 1, 0.0001).onChange(updatePoint);

			
			gui.add(params, 'compression', 0, 0.5, 0.0001).onChange(updatePoint);

			gui.add(params, 'r', 0, 1, 0.001).onChange(updatePoint);
			gui.add(params, 'g', 0, 1, 0.001).onChange(updatePoint);
			gui.add(params, 'b', 0, 1, 0.001).onChange(updatePoint);
			gui.add(params, 'intensity', 0, 20, 0.001).onChange(updatePoint);
			
			
			gui.add(params, 'saturation', 0, 4, 0.001).onChange(updatePoint);
			gui.add(params, 'ar', 0, 1, 0.01);
			gui.add(params, 'ag', 0, 1, 0.01);
			gui.add(params, 'ab', 0, 1, 0.01);

			gui.addColor(params, 'c');
			
			
			function render() {
				
				requestAnimationFrame( render );
				XYZrenderer.render( XYZscene, perspCameraXYZ );
				xyYrenderer.render( xyYscene, perspCamera_xyY );

			}
			render();

			window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){

				var aspect = (window.innerWidth * 0.4) / window.innerHeight;
			    perspCameraXYZ.aspect = aspect;
			    perspCameraXYZ.updateProjectionMatrix();

				perspCamera_xyY.aspect = aspect;
			    perspCamera_xyY.updateProjectionMatrix();

				/*
			    orthoCamera.left = frustumSize * aspect / - 2;
			    orthoCamera.right = frustumSize * aspect / 2;
			    orthoCamera.top = frustumSize / 2;
			    orthoCamera.bottom = frustumSize / - 2;

			    orthoCamera.updateProjectionMatrix();
				*/

			    XYZrenderer.setSize( window.innerWidth * 0.4, window.innerHeight );
			    xyYrenderer.setSize( window.innerWidth * 0.4, window.innerHeight );

			}
		</script>
		
		<script>
	</body>
</html>
