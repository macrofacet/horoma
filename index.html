<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Horoma - Color Explorer</title>
		<style>
			html, body { margin: 0; height:100% }
			canvas { width: 100%; height: 100%; }

			#container {
				display:flex;
				flex-direction: column;
				height: 100%;
				min-width: 0;
				min-height: 0;
			}

			.row {
				flex:1;
				display:flex;
				flex-direction: row;
				min-width: 0;
				min-height: 0;
			}

			.column {
				flex : 1;
				display:flex;
				flex-direction:column;
				min-width: 0;
				min-height: 0;
			}	

			#top {
				flex: 2;
			}

			#bottom {
				flex: 1;
				height: 450px;
				min-height: 450px;
			}

			.view {
				flex : 1;
				min-width: 0;
				min-height: 0;
			}

			.divider {
				background-color: gray; 
			}

			.header {
				background-color: rgb(70, 70, 70);
				padding: 5px;
				color: white;
				font-family: 'Courier New', Courier, monospace;
			}
			
		</style>
		
		<script async src="https://unpkg.com/es-module-shims@1.5.8/dist/es-module-shims.js"></script>
		<script type="importmap">
			{
			  "imports": {
				"three": "https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.module.js",
				"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/",
				"dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"
			  }
			}
		  </script>
	</head>
	<body>
		<div id="container">
			<div id="top" class="row">
				<div id="imageView" class="view"></div>
			</div>
			<div class="divider" style="min-height:2px"></div>
			<div id="bottom" class="row">
				<div class="column">
					<div class="header">xyY/XYZ View<input type="checkbox" id="viewswitch" autocomplete="off"></div>
					<div id="xyYView" class="view"></div>
				</div>
				<div class="divider" style="min-width:2px"></div>
				<div class="column">
					<div class="header">RGB View</div>
					<div id="RGBView" class="view"></div>
				</div>
			</div>
		</div>
		<script type='x-shader/x-vertex' id='point_vs'>

			uniform mat3 convMatXYZ;
			uniform vec2 whitePoint;

			uniform mat4 prematrix;
			uniform mat4 postmatrix;

			uniform int renderOption;

			uniform float exposure;			
			uniform float saturation;
			uniform float3 compression;
			uniform float3 rotation;

			uniform float rawlerp;
			uniform int lerpOption;

			varying vec3 vColorRGB;	



			void main() {
				vec3 colorAtt = color;
				vec3 preColor = (prematrix * vec4(colorAtt, 1.0)).rgb;

				vec3 AgXColor = max(preColor, 0.0);
				AgXColor *= pow(2.0, exposure);				
				AgXColor = apply_agx(AgXColor, compression, rotation);
				AgXColor = clamp(AgXColor, 0.0, 1.0);

				vec3 postColor = apply_saturation(AgXColor, saturation);
				postColor = (postmatrix * vec4(postColor, 1.0)).rgb;
				postColor = clamp(postColor, 0.0, 1.0);

				vec3 vColor = postColor;

				// Lerp between raw and image
				if(lerpOption == 0){ // raw and final
					vColor = mix(colorAtt, postColor, rawlerp);
				} else if (lerpOption == 1){
					vColor = mix(colorAtt, preColor, rawlerp);
				} else if (lerpOption == 2){					
					vColor = mix(preColor, AgXColor, rawlerp);
				} else if (lerpOption == 3){					
					vColor = mix(AgXColor, postColor, rawlerp);
				}

				vec3 localPos;

				if(renderOption == 0) {
					localPos = vColor;
				} else if(renderOption == 1) {
					localPos = convMatXYZ * vColor;
				} else if (renderOption == 2) {
					vec3 XYZPos = convMatXYZ * vColor;
					localPos = XYZ_to_xyY(XYZPos, whitePoint).xzy;
				}

				vec4 mvPosition = modelViewMatrix * vec4( localPos, 1.0 );
				gl_PointSize = 5.0;
				gl_Position = projectionMatrix * mvPosition;

				vColorRGB = vColor;
			}
		
		</script>
		
		<script type='x-shader/x-fragment' id='point_fs'>
			varying vec3 vColorRGB;	
		
			void main() {
				if (dot(gl_PointCoord-0.5,gl_PointCoord-0.5)>0.25)
					discard;
				else
			  		gl_FragColor = vec4( vColorRGB, 1 );
			}
		</script>

		<script  type="x-shader/x-vertex" id="image_vs">
			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position =  projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>

		<script  type="x-shader/x-fragment" id="image_ps">
			uniform sampler2D tex;
			uniform mat4 prematrix;
			uniform mat4 postmatrix;

			uniform float exposure;
			uniform float saturation;
			uniform float3 compression;
			uniform float3 rotation;
			varying vec2 vUv;

			void main() {
				vec3 vColor = texture2D(tex, vUv).rgb;
				vColor = (prematrix * vec4(vColor, 1.0)).rgb;

				vColor = max(vColor, 0.0);
				vColor *= pow(2.0, exposure);				
				vColor = apply_agx(vColor, compression, rotation);
				vColor = apply_saturation(vColor, saturation);
				vColor = clamp(vColor, 0.0, 1.0);

				vColor = (postmatrix * vec4(vColor, 1.0)).rgb;

				gl_FragColor = vec4(vColor, 1);
			}
		</script>

		<script type="x-shader/x-vertex" id="vertexShader">
			uniform mat3 convMatXYZ;
			uniform vec2 whitePoint;
			varying vec3 vColorRGB;
			uniform int renderOption;
			void main() {

				vec3 pos = position;
				vec3 vColor = (pos + 0.5); // box is centered at 0,0,0

				vec3 localPos;
				if(renderOption == 0) {
					localPos = vColor;
				} else if(renderOption == 1) {
					localPos = convMatXYZ * vColor;
				} else if (renderOption == 2) {
					vec3 XYZPos = convMatXYZ * vColor;
					localPos = XYZ_to_xyY(XYZPos, whitePoint).xzy;
				}

				vec4 mvPosition = modelViewMatrix * vec4( localPos, 1.0 );
				gl_Position = projectionMatrix * mvPosition;

				vColorRGB = vColor;
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">
			varying vec3 vColorRGB;
			uniform float opacity;
			void main() {
				vec3 rgb = vColorRGB;
				if(any(greaterThan(rgb - vec3(1.0, 1.0, 1.0), vec3(0.001, 0.001, 0.001))) || any(lessThan(rgb, -vec3(0.001, 0.001, 0.001))))
				{	
					gl_FragColor = vec4( 0.1, 0.1, 0.1, opacity );	
				}
				else
				{				
					gl_FragColor = vec4( rgb, opacity );					
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import { EXRLoader } from "three/addons/loaders/EXRLoader.js";

			import {Pane} from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';


			import * as Utils from './js/utils.js'
			import * as Generator from './js/generator.js'
			import * as Inset from './js/inset.js'
			
			import agx_common from './shaderchunk/agx_common.glsl.js'

			var images = { loadCount: 0, numImages: 3 };

			var xmas_loader = new EXRLoader().setDataType(THREE.FloatType)
			.load( "./images/red_xmas_rec709.exr", function ( texture, textureData ) {
							images.xmas = textureData.data;
							images.loadCount += 1;
							});
			var lightsaber_loader = new EXRLoader().setDataType(THREE.FloatType)
			.load( "./images/mery_lightSaber_lin_srgb.exr", function ( texture, textureData ) {
							images.lightsaber = textureData.data;
							images.loadCount += 1;
							});

			var bluebar_loader = new EXRLoader().setDataType(THREE.FloatType)
			.load( "./images/blue_bar_709.exr", function ( texture, textureData ) {
							images.bar = textureData.data;
							images.loadCount += 1;
							});
			
			var cmfData = await Utils.getCMFData();

			var custom_texture = new THREE.DataTexture();

			var aspect = 1.0;

			// xyY Scene
			var xyYscene = new THREE.Scene();
			xyYscene.background = new THREE.Color( "rgb(0,0,0)" );
			
			var xyYrenderer = new THREE.WebGLRenderer();
			document.getElementById("xyYView").appendChild( xyYrenderer.domElement );
			
			var perspCamera_xyY = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000 );
			perspCamera_xyY.position.z = 3;

			// XYZ Scene
			var RGBscene = new THREE.Scene();
			RGBscene.background = new THREE.Color( "rgb(0,0,0)" );

			var RGBrenderer = new THREE.WebGLRenderer();
			document.getElementById("RGBView").appendChild( RGBrenderer.domElement );
			
			var perspCamera_RGB = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000 );
			perspCamera_RGB.position.z = 3;
			
			// Image Scene
			var ImageRenderer = new THREE.WebGLRenderer();
			document.getElementById("imageView").appendChild( ImageRenderer.domElement );

			var ImageScene = new THREE.Scene();
			ImageScene.background = new THREE.Color( "rgb(127,127,127)" );			

			var perspCamera_Image = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000 );
			perspCamera_Image.position.z = 1;

			// ----

			// IMAGE SCENE
			var quad_mat = new THREE.ShaderMaterial( {
			uniforms: {
				tex: {value: null, type:"t"},
				prematrix:{value:new THREE.Matrix4()},
				postmatrix:{value:new THREE.Matrix4()},
				exposure: {value:0},
				saturation:{value:1},
				compression:{value:new THREE.Vector3(0, 0, 0)},
				rotation:{value:new THREE.Vector3(0,0,0)},
				min_ev:{value:-10.0},
				max_ev:{value:6.5},
				slope:{value:2.3},
				toe_power:{value:1.9},
				shoulder_power:{value:3.1}
			},
			depthTest: false,
			vertexShader: document.getElementById( 'image_vs' ).textContent,
			fragmentShader: agx_common + "\n" + document.getElementById( 'image_ps' ).textContent
			} );

			const dropArea = document.getElementById('top');

			dropArea.addEventListener('dragover', (event) => {
				event.stopPropagation();
				event.preventDefault();
				// Style the drag-and-drop as a "copy file" operation.
				event.dataTransfer.dropEffect = 'copy';
			});

			dropArea.addEventListener('drop', (event) => {
				event.stopPropagation();
				event.preventDefault();
				const fileList = event.dataTransfer.files;
				if(fileList.length)
				{
					var file = fileList[0];
					if (!file.name.endsWith("exr")) {
						alert("Unsupported file type. Please select a EXR file.");
						return;
					}
					// Read the file
					const reader = new FileReader();

					reader.onload = () => {
						custom_texture = new THREE.DataTexture();
						let tex = new EXRLoader().setDataType(THREE.FloatType).parse(reader.result);
						custom_texture.image.data = tex.data;
						custom_texture.image.width = tex.width;
						custom_texture.image.height = tex.height;
						custom_texture.type = tex.type;
						custom_texture.format = tex.format;
						custom_texture.needsUpdate = true;

						// Update UI and all
						params.generator = "image";
						params.image = "custom";
						updateSamples();
					};
					reader.onerror = () => {
						alert("Error reading the file. Please cry in a corner.");
					};

					reader.readAsArrayBuffer(file);
				}
			});


			const quad = new THREE.PlaneGeometry( 1, 1 );
			const mesh = new THREE.Mesh( quad, quad_mat );
			ImageScene.add( mesh );


			// COMMON SCENE 
			var pointCloudGeo = new THREE.BufferGeometry();		
			const positions = [];
			const colors = [];
			pointCloudGeo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
			pointCloudGeo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
			pointCloudGeo.computeBoundingSphere();

			var boxGeo = new THREE.BoxGeometry(1, 1, 1, 20, 20, 20);

			// xyY/XYZ SCENE

			var material709_xyY = new THREE.ShaderMaterial( {
			uniforms: {
				convMatXYZ: { value: Utils.sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
				opacity: {value: 0.5},
				renderOption:{value: 2},
			},
			depthTest: false,
			vertexShader:  agx_common + "\n" + document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );

			material709_xyY.transparent = true;
			material709_xyY.opacity = 0.1;

			var cube709_xyY = new THREE.Mesh( boxGeo, material709_xyY );
			cube709_xyY.renderOrder = 0;
			xyYscene.add(cube709_xyY);

			var axesHelper = new THREE.AxesHelper( 1 );
			xyYscene.add( axesHelper );

			// point cloud material
			var pointShaderMaterial_xyY = new THREE.ShaderMaterial( {
				uniforms: {
					convMatXYZ: { value: Utils.sRGB_to_XYZ },
					whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
					renderOption:{ value: 2},
					saturation: {value: 1.0},
					rawlerp:{value:1.0},
					lerpOption:{ value: 0},
					exposure:{value:1.0},
					prematrix:{value:new THREE.Matrix4()},
					postmatrix:{value:new THREE.Matrix4()},
					compression:{value:new THREE.Vector3(0, 0, 0)},
					rotation:{value:new THREE.Vector3(0,0,0)},
					min_ev:{value:-10.0},
					max_ev:{value:6.5},
					slope:{value:2.5},
					toe_power:{value:3},
					shoulder_power:{value:3.25}
				},
				vertexShader:  agx_common + "\n" +  document.getElementById( 'point_vs' ).textContent,
				fragmentShader: document.getElementById( 'point_fs' ).textContent,
				transparent:  true,
				vertexColors: true
			});
			var point_xyY = new THREE.Points(pointCloudGeo, pointShaderMaterial_xyY);
			point_xyY.renderOrder = 1;
			xyYscene.add( point_xyY );

			var controls_xyY = new OrbitControls( perspCamera_xyY, xyYrenderer.domElement );
			controls_xyY.target.y = 0.5;
			controls_xyY.target.x = 0.5;
			controls_xyY.target.z = 0.5;
			controls_xyY.damping = 0.2;
			controls_xyY.update();

			const material = new THREE.LineBasicMaterial( { color: 0xFFFFFF } );
			const points = [];
			
			var sum = [];
			for(var i = 0; i < cmfData.high - cmfData.low; i++)
			{
				sum.push(cmfData.x[i] + cmfData.y[i] + cmfData.z[i]);
			}

			for(var i = 0; i < cmfData.high - cmfData.low; i++)
			{
				points.push( new THREE.Vector3(cmfData.y[i]/sum[i], cmfData.y[i], cmfData.x[i]/sum[i] ) );
			}
			const geometry = new THREE.BufferGeometry().setFromPoints( points );
			const line = new THREE.Line( geometry, material );
			xyYscene.add( line );

			//RGB SCENE
			/*
			var material709_RGB = new THREE.ShaderMaterial( {
			uniforms: {
				convMatXYZ: { value: Utils.sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
				opacity: {value: 0.5},
				to_xyY: {value: false}
			},
			depthTest: false,
			vertexShader: document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );

			material709_RGB.transparent = true;
			material709_RGB.opacity = 0.1;
			*/
			var axesHelper = new THREE.AxesHelper( 1 );
			RGBscene.add(axesHelper);

			// point cloud material
			var pointShaderMaterial_RGB = new THREE.ShaderMaterial( {
				uniforms: {
					convMatXYZ: { value: Utils.sRGB_to_XYZ },
					whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
					renderOption:{ value: 0},
					saturation: {value: 1.0},
					lerpOption:{ value: 0},
					rawlerp:{value:1.0},
					exposure:{value:1.0},
					prematrix:{value:new THREE.Matrix4()},
					postmatrix:{value:new THREE.Matrix4()},
					compression:{value:new THREE.Vector3(0, 0, 0)},
					rotation:{value:new THREE.Vector3(0,0,0)},
					min_ev:{value:-10.0},
					max_ev:{value:6.5},
					slope:{value:2.5},
					toe_power:{value:3},
					shoulder_power:{value:3.25}
				},
				vertexShader:  agx_common + "\n" +  document.getElementById( 'point_vs' ).textContent,
				fragmentShader: document.getElementById( 'point_fs' ).textContent,
				transparent:  true,
				vertexColors: true
			});

			var point_RGB = new THREE.Points(pointCloudGeo, pointShaderMaterial_RGB);
			point_RGB.renderOrder = 1;
			RGBscene.add( point_RGB );

			var controls_RGB = new OrbitControls( perspCamera_RGB, RGBrenderer.domElement );
			controls_RGB.target.y = 0.5;
			controls_RGB.target.x = 0.5;
			controls_RGB.target.z = 0.5;
			controls_RGB.damping = 0.2;
			controls_RGB.update();

			// UI

			var xySwitch = false;

			var params = { 
						generator:"image",
						steps:1,
						start:-10,
						range:20,
						substeps:1,
						ratio:{r:0,g:0,b:0},
						image:"lightsaber",
						exposure:0,
						order:"SRT",
						pre_neutral_axis:{r:255,g:255,b:255},
						pre_translate_neutral:0,
						pre_translate_a:0,
						pre_translate_b:0,
						pre_rotate_angle:0,
						pre_scale_neutral:1,
						pre_scale_a:1,
						pre_scale_b:1,
						pre_tilt_axis:{r:255,g:255,b:255},
						compression:{x:0.10, y:0.10, z:0.10},
						rotation:{x:0, y: 0, z: 0},
						min_ev:-10,
						max_ev:6.5,
						slope:2,
						toe_power:3,
						shoulder_power:3.25,
						post_neutral_axis:{r:255,g:255,b:255},
						post_translate_neutral:0,
						post_translate_a:0,
						post_translate_b:0,
						post_rotate_angle:0,
						post_scale_neutral:1,
						post_scale_a:1,
						post_scale_b:1,
						post_tilt_axis:{r:255,g:255,b:255},
						saturation:1,
						lerp:1,
						lerpOption:"raw-post",
						img_exp:0,
						ortho:false};

			var gui = new Pane({title:"Parameters"});

			var samples = [];
			function updateSamples()
			{
				samples.length = 0;

				const steps = params.steps;
				const range = params.range;
				const start = params.start;
				const substeps = params.substeps;
				
				switch(params.generator)
				{
					case 'single':
					var ratio = new THREE.Vector3();
					ratio.x = params.ratio[0];
					ratio.y = params.ratio[1];
					ratio.z = params.ratio[2];

					samples = Generator.GenerateLine(ratio, substeps, start, range);
					break;
					
					case 'image' :
						var texture = null;
						switch(params.image)
						{
							case "lightsaber": texture = lightsaber_loader; break;
							case "bar": texture = bluebar_loader; break;
							case "xmas": texture = xmas_loader; break;
							case "custom": texture = custom_texture; break;
							default : return;
						}

						var sourceData = texture.image.data;
						texture.magFilter = texture.minFilter = THREE.NearestFilter;
						quad_mat.uniforms.tex.value = texture;
						mesh.scale.x = texture.source.data.width/texture.source.data.height;

						for(var i = 0; i < sourceData.length; i+=4)
						{
							samples.push(new THREE.Vector3(sourceData[i], sourceData[i+1], sourceData[i+2]));
						}
					break;

					case 'generic':
					default:
						samples = Generator.GenerateRamp(steps, substeps, start, range);
					break;

				}

				updatePoint();
			}

			function GetTransformMatrix(axis, translation, rotation, scale, order)
			{
				var Quat = new THREE.Quaternion().setFromUnitVectors(axis.clone().normalize(), new THREE.Vector3(1, 0, 0));
				var TranslationMatrix = new THREE.Matrix4().makeTranslation(translation.x, translation.y, translation.z);
				var ForwardMatrix = new THREE.Matrix4().makeRotationFromQuaternion(Quat);
				var ReverseForwardMatrix = ForwardMatrix.clone().invert();

				var RotationMatrix = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0).normalize(), rotation * Math.PI / 180);
				var ScaleMatrix = new THREE.Matrix4().makeScale(scale.x, scale.y, scale.z);

				var TransformMatrix = new THREE.Matrix4();
				switch(order)
				{
					case 'TRS':
						TransformMatrix = ScaleMatrix.multiply(RotationMatrix).multiply(TranslationMatrix);
						break;
					case 'TSR':
						TransformMatrix = RotationMatrix.multiply(ScaleMatrix).multiply(TranslationMatrix);
						break;
					case 'RST':
						TransformMatrix = TranslationMatrix.multiply(ScaleMatrix).multiply(RotationMatrix);
						break;
					case 'SRT':
						TransformMatrix = TranslationMatrix.multiply(RotationMatrix).multiply(ScaleMatrix);
						break;
				}
				
				return ReverseForwardMatrix.multiply(TransformMatrix).multiply(ForwardMatrix).clone();
			}

			function updateUniforms()
			{
				var PreMatrix = GetTransformMatrix(new THREE.Vector3(params.pre_neutral_axis[0], params.pre_neutral_axis[1], params.pre_neutral_axis[2]),
													new THREE.Vector3(params.pre_translate_neutral, params.pre_translate_a, params.pre_translate_b),
													params.pre_rotate_angle,
													new THREE.Vector3(params.pre_scale_neutral, params.pre_scale_a, params.pre_scale_b),
													params.order);

				var PreTiltQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(params.pre_tilt_axis[0], params.pre_tilt_axis[1], params.pre_tilt_axis[2]).normalize(), new THREE.Vector3(1, 1, 1).normalize());
				var PreTiltMatrix = new THREE.Matrix4().makeRotationFromQuaternion(PreTiltQuat);

				PreMatrix = PreMatrix.multiply(PreTiltMatrix);

				var PostMatrix = GetTransformMatrix(new THREE.Vector3(params.post_neutral_axis[0], params.post_neutral_axis[1], params.post_neutral_axis[2]),
													new THREE.Vector3(params.post_translate_neutral, params.post_translate_a, params.post_translate_b),
													params.post_rotate_angle,
													new THREE.Vector3(params.post_scale_neutral, params.post_scale_a, params.post_scale_b),
													params.order);

				var PostTiltQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(params.post_tilt_axis[0], params.post_tilt_axis[1], params.post_tilt_axis[2]).normalize(), new THREE.Vector3(1, 1, 1).normalize());
				var PostTiltMatrix = new THREE.Matrix4().makeRotationFromQuaternion(PostTiltQuat);

				PostMatrix = PostMatrix.multiply(PostTiltMatrix);

				pointShaderMaterial_xyY.uniforms.exposure.value = params.exposure;
				pointShaderMaterial_xyY.uniforms.rawlerp.value = params.lerp;
				pointShaderMaterial_xyY.uniforms.saturation.value = params.saturation;
				
				pointShaderMaterial_xyY.uniforms.compression.value = new THREE.Vector3(params.compression.x, params.compression.y, params.compression.z);
				pointShaderMaterial_xyY.uniforms.rotation.value = new THREE.Vector3(params.rotation.x, params.rotation.y, params.rotation.z);
				pointShaderMaterial_xyY.uniforms.min_ev.value = params.min_ev;
				pointShaderMaterial_xyY.uniforms.max_ev.value = params.max_ev;
				pointShaderMaterial_xyY.uniforms.slope.value = params.slope;
				pointShaderMaterial_xyY.uniforms.toe_power.value = params.toe_power;
				pointShaderMaterial_xyY.uniforms.shoulder_power.value = params.shoulder_power;
				pointShaderMaterial_xyY.uniforms.prematrix.value = PreMatrix.clone();
				pointShaderMaterial_xyY.uniforms.postmatrix.value = PostMatrix.clone();
				

				pointShaderMaterial_RGB.uniforms.exposure.value = params.exposure;
				pointShaderMaterial_RGB.uniforms.rawlerp.value = params.lerp;
				pointShaderMaterial_RGB.uniforms.saturation.value = params.saturation;
				
				pointShaderMaterial_RGB.uniforms.compression.value = new THREE.Vector3(params.compression.x, params.compression.y, params.compression.z);
				pointShaderMaterial_RGB.uniforms.rotation.value = new THREE.Vector3(params.rotation.x, params.rotation.y, params.rotation.z);
				pointShaderMaterial_RGB.uniforms.min_ev.value = params.min_ev;
				pointShaderMaterial_RGB.uniforms.max_ev.value = params.max_ev;
				pointShaderMaterial_RGB.uniforms.slope.value = params.slope;
				pointShaderMaterial_RGB.uniforms.toe_power.value = params.toe_power;
				pointShaderMaterial_RGB.uniforms.shoulder_power.value = params.shoulder_power;				
				pointShaderMaterial_RGB.uniforms.prematrix.value = PreMatrix.clone();		
				pointShaderMaterial_RGB.uniforms.postmatrix.value = PostMatrix.clone();

				pointShaderMaterial_xyY.uniforms.renderOption.value = xySwitch ? 1 : 2;
				material709_xyY.uniforms.renderOption.value = pointShaderMaterial_xyY.uniforms.renderOption.value;

				var lerpOptionIndex = ['raw-post', 'raw-pre', 'pre-image', 'image-post'].indexOf(params.lerpOption);
				pointShaderMaterial_xyY.uniforms.lerpOption.value = lerpOptionIndex;
				pointShaderMaterial_RGB.uniforms.lerpOption.value = lerpOptionIndex;

				quad_mat.uniforms.exposure.value = params.exposure;
				quad_mat.uniforms.saturation.value = params.saturation;	

				quad_mat.uniforms.compression.value = new THREE.Vector3(params.compression.x, params.compression.y, params.compression.z);
				quad_mat.uniforms.rotation.value = new THREE.Vector3(params.rotation.x, params.rotation.y, params.rotation.z);
				quad_mat.uniforms.min_ev.value = params.min_ev;
				quad_mat.uniforms.max_ev.value = params.max_ev;
				quad_mat.uniforms.slope.value = params.slope;
				quad_mat.uniforms.toe_power.value = params.toe_power;
				quad_mat.uniforms.shoulder_power.value = params.shoulder_power;
				quad_mat.uniforms.prematrix.value = PreMatrix.clone();
				quad_mat.uniforms.postmatrix.value = PostMatrix.clone();
			}

			function updatePoint()
			{	
				Inset.setCompressionMatrix(params.compression);
				
				const positions = [];
				const colors = [];
				
				for ( let s = 0; s < samples.length; s ++ )
				{
					var p = samples[s];
					p.x = p.x * Math.pow(2, params.exposure);
					p.y = p.y * Math.pow(2, params.exposure);
					p.z = p.z * Math.pow(2, params.exposure);	
					
					colors.push(p.x, p.y, p.z);

					p.max(new THREE.Vector3(0, 0, 0));

					positions.push(p.x, p.y, p.z);
				}

				pointCloudGeo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				pointCloudGeo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				pointCloudGeo.computeBoundingSphere();

				gui.refresh();
			}

			/*
			gui.addBinding(params, 'generator', {options: {generic:'generic', single:'single', image:'image'}}).on('change', (e) => {
				genericGeneratorFolder.hidden = true;
				singleGeneratorFolder.hidden = true;
				imageGeneratorFolder.hidden = true;

				switch(e.value) 
				{
					case "generic" : genericGeneratorFolder.hidden = false; break;
					case "single" : singleGeneratorFolder.hidden = false; break;
					case "image" : imageGeneratorFolder.hidden = false; break;
				}
			});

			var genericGeneratorFolder = gui.addFolder({title:"Generic"});
			genericGeneratorFolder.addBinding(params, 'steps', {min:1, max:20, step:1}).on('change', updateSamples);
			genericGeneratorFolder.addBinding(params, 'start', {min:-20, max:20, step:1}).on('change', updateSamples);
			genericGeneratorFolder.addBinding(params, 'range', {min:0, max:20, step:1}).on('change', updateSamples);
			genericGeneratorFolder.addBinding(params, 'substeps', {min:1, max:20, step:1}).on('change', updateSamples);
			genericGeneratorFolder.hidden = true;

			var singleGeneratorFolder = gui.addFolder({title:"Single"});
			singleGeneratorFolder.addBinding(params, 'ratio').on('change', updateSamples);
			singleGeneratorFolder.hidden = true;

			var imageGeneratorFolder = gui.addFolder({title:"Image"});
			*/
			gui.addBinding(params, 'image', {options:{xmas:'xmas', lightsaber:'lightsaber', bar:'bar', custom:'custom'}}).on('change', updateSamples);
			
			
			/*
			var preFolder = gui.addFolder({title:"Pre"});

			preFolder.addColor(params, 'pre_neutral_axis').onChange(updateUniforms);

			preFolder.add(params, 'order', ['TRS', 'TSR', 'RST', 'SRT']).onChange(updateUniforms);
			
			preFolder.add(params, 'pre_translate_neutral',-1, 1, 0.01).onChange(updateUniforms);
			preFolder.add(params, 'pre_translate_a',-1, 1, 0.01).onChange(updateUniforms);
			preFolder.add(params, 'pre_translate_b',-1, 1, 0.01).onChange(updateUniforms);
			
			preFolder.add(params, 'pre_rotate_angle',-360, 360, 1).onChange(updateUniforms);

			preFolder.add(params, 'pre_scale_neutral',-2, 2, 0.01).onChange(updateUniforms);
			preFolder.add(params, 'pre_scale_a',-2, 2, 0.01).onChange(updateUniforms);
			preFolder.add(params, 'pre_scale_b',-2, 2, 0.01).onChange(updateUniforms);

			preFolder.addColor(params, 'pre_tilt_axis').onChange(updateUniforms);
			*/

			var algorithmFolder = gui.addFolder({title:"AgX"});
			algorithmFolder.addBinding(params, 'exposure', {min:-20, max:20, step:0.1}).on('change', updateUniforms);
			algorithmFolder.addBinding(params, 'compression', {min:0, max:0.5, step:0.01}).on('change', updateUniforms);
			algorithmFolder.addBinding(params, 'rotation', {min:-10, max:10, step:0.01}).on('change', updateUniforms);
			
			algorithmFolder.addBinding(params, 'min_ev', {min:-20, max:20, step:0.1}).on('change', updateUniforms);
			algorithmFolder.addBinding(params, 'max_ev', {min:0, max:20, step:0.1}).on('change', updateUniforms);

			algorithmFolder.addBinding(params, 'slope', {min:0, max:10, step:0.01}).on('change', updateUniforms);
			algorithmFolder.addBinding(params, 'toe_power', {min:0, max:10, step:0.01}).on('change', updateUniforms);
			algorithmFolder.addBinding(params, 'shoulder_power', {min:0, max:10, step:0.01}).on('change', updateUniforms);
			
			/*
			var postFolder = gui.addFolder({title:"Post"});
			postFolder.add(params, 'saturation', 0, 4, 0.001).onChange(updateUniforms);		
			
			postFolder.addColor(params, 'post_neutral_axis').onChange(updateUniforms);

			postFolder.add(params, 'order', ['TRS', 'TSR', 'RST', 'SRT']).onChange(updateUniforms);

			postFolder.add(params, 'post_translate_neutral',-2, 2, 0.01).onChange(updateUniforms);
			postFolder.add(params, 'post_translate_a',-1, 1, 0.01).onChange(updateUniforms);
			postFolder.add(params, 'post_translate_b',-1, 1, 0.01).onChange(updateUniforms);

			postFolder.add(params, 'post_rotate_angle',-360, 360, 1).onChange(updateUniforms);

			postFolder.add(params, 'post_scale_neutral',-2, 2, 0.01).onChange(updateUniforms);
			postFolder.add(params, 'post_scale_a',-2, 2, 0.01).onChange(updateUniforms);
			postFolder.add(params, 'post_scale_b',-2, 2, 0.01).onChange(updateUniforms);
			
			postFolder.addColor(params, 'post_tilt_axis').onChange(updateUniforms);
			
			*/
			gui.addBinding(params, 'lerp', {min:0, max:1, step:0.01}).on('change', updateUniforms);
			//gui.addBinding(params, 'lerpOption', {options:{raw_post:'raw-post', raw_pre:'raw-pre', pre_image:'pre-image', image_post:'image-post'}}).on('change', updateUniforms);
			

			function resizeRendererToDisplaySize(renderer, camera, container) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				if (canvas.width !== width || canvas.height !== height) {
					renderer.setSize(width, height, false);
					camera.aspect = width / height;
					camera.updateProjectionMatrix();
				}
			}



			function render() {
				
				if(images.loadCount == images.numImages)
				{	
					updateSamples();
					updateUniforms();
					images.loadCount = 0;
				}

				requestAnimationFrame( render );
				resizeRendererToDisplaySize(ImageRenderer, perspCamera_Image, document.getElementById("imageView"));
				resizeRendererToDisplaySize(xyYrenderer, perspCamera_xyY, document.getElementById("xyYView"));
				resizeRendererToDisplaySize(RGBrenderer, perspCamera_RGB, document.getElementById("RGBView"));
				
				ImageRenderer.render( ImageScene, perspCamera_Image );
				xyYrenderer.render( xyYscene, perspCamera_xyY );
				RGBrenderer.render( RGBscene, perspCamera_RGB );
			}

			render();

			document.getElementById("viewswitch").addEventListener("click", OnViewSwitchClicked);
			function OnViewSwitchClicked()
			{
				xySwitch = document.getElementById("viewswitch").checked;
				updateUniforms();
			}
			/*
			window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){

				var aspect = (window.innerWidth) / window.innerHeight;

				//perspCamera_xyY.aspect = aspect;
			    //perspCamera_xyY.updateProjectionMatrix();
			    //xyYrenderer.setSize( window.innerWidth, window.innerHeight );
			}
			*/
		</script>
	</body>
</html>


