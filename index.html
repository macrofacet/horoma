<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Horoma - Color Explorer</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="xyYView" style="display:inline-block"></div>

		<script src="js/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		
		<script type="text/javascript" src="js/dat.gui.min.js"></script>

		<script src="js/utils.js"></script>
		<script src="js/inset.js"></script>
		<script src="js/generator.js"></script>


		<script type='x-shader/x-vertex' id='point_vs'>
			
			uniform mat3 convMatXYZ;	
			uniform vec2 whitePoint;
			varying vec3 vColorRGB;	
			void main() {
				vColorRGB = position;
			/*
			 	vec3 xyz = convMatXYZ * vColorRGB;
				
				float sum = xyz.x + xyz.y + xyz.z;
				vec3 xyY = vec3(0, 0, 0);
				if(sum != 0.0)
				{
					xyY.x = xyz.x / sum;
					xyY.y = xyz.y / sum;
					xyY.z = xyz.y;
				}
				else
				{
					xyY.x = whitePoint.x;
					xyY.y = whitePoint.y;
					xyY.z = xyz.y;
				}
			*/
			  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			  gl_PointSize = 5.0;
			  gl_Position = projectionMatrix * mvPosition;
			}
		
		  </script>
		
		  <script type='x-shader/x-fragment' id='point_fs'>
			varying vec3 vColorRGB;	
		
			void main() {
			  gl_FragColor = vec4( vColorRGB, 1 );
			}
		  </script>


		<script type="x-shader/x-vertex" id="vertexShader">
			uniform mat3 convMatXYZ;
			uniform vec2 whitePoint;
			varying vec3 vColorRGB;
			void main() {

				vec3 pos = position;
				vec3 rgb = (pos + 0.5); // box is centered at 0,0,0
 
				vec3 xyz = convMatXYZ * rgb;
				vec3 position;
				float sum = xyz.x + xyz.y + xyz.z;
				vec3 xyY = vec3(0, 0, 0);
				if(sum != 0.0)
				{
					xyY.x = xyz.x / sum;
					xyY.y = xyz.y / sum;
					xyY.z = xyz.y;
				}
				else
				{
					xyY.x = whitePoint.x;
					xyY.y = whitePoint.y;
					xyY.z = xyz.y;
				}
				position = xyY;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;

				vColorRGB = rgb;
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">
			varying vec3 vColorRGB;
			uniform float opacity;
			void main() {
				vec3 rgb = vColorRGB;
				if(any(greaterThan(rgb - vec3(1.0, 1.0, 1.0), vec3(0.001, 0.001, 0.001))) || any(lessThan(rgb, -vec3(0.001, 0.001, 0.001))))
				{	
					gl_FragColor = vec4( 0.1, 0.1, 0.1, opacity );	
				}
				else
				{				
					gl_FragColor = vec4( rgb, opacity );					
				}
			}
		</script>
		<script>			
			var aspect = window.innerWidth / window.innerHeight;

			var xyYscene = new THREE.Scene();
			xyYscene.background = new THREE.Color( "rgb(127,127,127)" );
			var frustumSize = 2;
			
			var perspCamera_xyY = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000 );
			perspCamera_xyY.position.z = 5;
			
			var xyYrenderer = new THREE.WebGLRenderer();
			xyYrenderer.setSize( window.innerWidth, window.innerHeight );
			document.getElementById("xyYView").appendChild( xyYrenderer.domElement );

			var boxGeo = new THREE.BoxGeometry(1, 1, 1, 20, 20, 20);

			var material709_xyY = new THREE.ShaderMaterial( {
			uniforms: {
				convMatXYZ: { value: sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) },
				opacity: {value: 0.1}
			},
			depthTest: false,
			vertexShader: document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );

			material709_xyY.transparent = true;
			material709_xyY.opacity = 0.1;

			var cube709_xyY = new THREE.Mesh( boxGeo, material709_xyY );
			cube709_xyY.renderOrder = 0;
			//xyYscene.add(cube709_xyY);

			var triangle = new THREE.Geometry();
			triangle.dynamic = true;
			triangle.vertices.push(new THREE.Vector3(-1, -1, 1));
			triangle.vertices.push(new THREE.Vector3(1, -1, 1));
			triangle.vertices.push(new THREE.Vector3(0, 1, 1));
			triangle.vertices.push(new THREE.Vector3(-1, -1, 1));

			var axesHelper = new THREE.AxesHelper( 1 );
			xyYscene.add( axesHelper );

			var size = 10;
			var divisions = 10;

			var controls_xyY = new THREE.OrbitControls( perspCamera_xyY, xyYrenderer.domElement );
			controls_xyY.damping = 0.2;
			
			var pointCloudGeo = new THREE.BufferGeometry();

			const positions = [];
			pointCloudGeo.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
			pointCloudGeo.computeBoundingSphere();

			// uniforms
			var uniforms = {
				convMatXYZ: { value: sRGB_to_XYZ },
				whitePoint: {value: new THREE.Vector2(0.3127, 0.3290) }
			};

			// point cloud material
			var pointShaderMaterial = new THREE.ShaderMaterial( {
				uniforms:     uniforms,
				vertexShader:   document.getElementById( 'point_vs' ).textContent,
				fragmentShader: document.getElementById( 'point_fs' ).textContent,
				transparent:  true,
			});

			var point_xyY = new THREE.Points(pointCloudGeo, pointShaderMaterial);
			point_xyY.renderOrder = 1;
			xyYscene.add( point_xyY );
			

			// UI

			var params = {compression:0, 
						saturation:1,
						steps:1,
						start:-10,
						range:20,
						substeps:1,
						min_ev:-10,
						max_ev:7,
						slope:2.5,
						toe_power:1.9,
						shoulder_power:3.1,
						lerp:1,
						useRatio:false,
						ratio:[0,0,0],
						ortho:false};

			var gui = new dat.GUI();

			var samples = [];
			function updateSamples()
			{
				const steps = params.steps;
				const range = params.range;
				const start = params.start;
				const substeps = params.substeps;
				
				if(params.useRatio)
				{
					var ratio = new THREE.Vector3();
					ratio.x = params.ratio[0];
					ratio.y = params.ratio[1];
					ratio.z = params.ratio[2];

					samples = GenerateLine(ratio, substeps, start, range);
				}
				else
				{
					samples = GenerateRamp(steps, substeps, start, range);
				}

				updatePoint();
			}

			
			function updatePoint()
			{	
				adjusted_to_XYZ = ComputeCompressionMatrix(sRGB_Space.red, sRGB_Space.green, sRGB_Space.blue, sRGB_Space.white, params.compression);
				XYZ_to_adjusted = new THREE.Matrix3().getInverse(adjusted_to_XYZ);

				const positions = [];
				
				for ( let s = 0; s < samples.length; s ++ )
				{
					var p = samples[s];
					var tp = applyInsetTransform(p.clone(), params.slope, params.toe_power, params.shoulder_power, params.min_ev, params.max_ev);
					
					// Saturation
					const wgt = new THREE.Vector3(0.2126729,  0.7151522,  0.0721750); // srgb luminance
					var des = tp.clone().dot(wgt);
					tp.x = lerp(des, tp.x, params.saturation);
					tp.y = lerp(des, tp.y, params.saturation);
					tp.z = lerp(des, tp.z, params.saturation);
			
					tp.x = Math.min(Math.max(tp.x, 0), 1);
					tp.y = Math.min(Math.max(tp.y, 0), 1);
					tp.z = Math.min(Math.max(tp.z, 0), 1);

					// Lerp between raw and image
					var fp = new THREE.Vector3();
					fp.x = lerp(p.x, tp.x, params.lerp);
					fp.y = lerp(p.y, tp.y, params.lerp);
					fp.z = lerp(p.z, tp.z, params.lerp);

					positions.push(fp.x, fp.y, fp.z);
				}

				pointCloudGeo.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				pointCloudGeo.computeBoundingSphere();

				for (var i in gui.__controllers) {
					gui.__controllers[i].updateDisplay();
				}
			}

			updateSamples();

			gui.add(params, 'steps', 1, 20, 1).onChange(updateSamples);
			gui.add(params, 'start', -20, 20, 1).onChange(updateSamples);
			gui.add(params, 'range', 0, 20, 1).onChange(updateSamples);
			gui.add(params, 'substeps', 0, 20, 1).onChange(updateSamples);

			gui.add(params, 'useRatio').onChange(updateSamples);
			gui.addColor(params, 'ratio').onChange(updateSamples);
			
			gui.add(params, 'compression', 0, 0.5, 0.0001).onChange(updatePoint);
			gui.add(params, 'min_ev', -20, 20, 1).onChange(updatePoint);
			gui.add(params, 'max_ev', 0, 20, 1).onChange(updatePoint);

			gui.add(params, 'slope', 0, 10, 0.01).onChange(updatePoint);
			gui.add(params, 'toe_power', 0, 10, 0.01).onChange(updatePoint);
			gui.add(params, 'shoulder_power', 0, 10, 0.01).onChange(updatePoint);

			gui.add(params, 'saturation', 0, 4, 0.001).onChange(updatePoint);
			gui.add(params, 'lerp', 0, 1, 0.01).onChange(updatePoint);

			
			
			function render() {
				
				requestAnimationFrame( render );
				xyYrenderer.render( xyYscene, perspCamera_xyY );

			}

			render();

			window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){

				var aspect = (window.innerWidth) / window.innerHeight;

				perspCamera_xyY.aspect = aspect;
			    perspCamera_xyY.updateProjectionMatrix();
			    xyYrenderer.setSize( window.innerWidth, window.innerHeight );
			}
		</script>
	</body>
</html>
